<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>BLOCK 'EM, DUKE!</title>
    <style>
      /* Fuerza que html y body ocupen toda la ventana sin márgenes */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background-color: black;
        overflow: hidden;
      }
      
      /* Pantalla de inicio que cubre toda la ventana */
      #startScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }
      
      #startScreen h1 {
        color: white;
        font-size: 2.5em;
        margin-bottom: 20px;
      }
      
      #startScreen button {
        padding: 10px 20px;
        font-size: 1.5em;
        cursor: pointer;
      }
      
      /* Contenedor del juego: ocupa toda la ventana y centra los canvas */
      #gameContainer {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: black;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      
      /* Los canvas tienen resolución interna fija, pero se escalan con JS */
      canvas {
        border: 2px solid white;
        background-color: #000;
      }
      
      /* Timer centrado en la parte inferior */
      #timer {
        position: fixed;
        bottom: 0;
        width: 100%;
        text-align: center;
        color: white;
        font-size: 1.5em;
        padding: 5px;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <!-- Pantalla de inicio -->
    <div id="startScreen">
      <h1>BLOCK 'EM, DUKE!</h1>
      <button id="playButton">I Came Here to Kick Ass and Nuke Pieces!</button>
    </div>
    
    <!-- Contenedor del juego -->
    <div id="gameContainer">
      <!-- El canvas de la imagen DEBE ir detrás para efectos de revelado -->
      <canvas id="imageCanvas"></canvas>
      <canvas id="gameCanvas"></canvas>
    </div>
    
    <div id="timer"></div>
    
    <script>
      "use strict";
      // Parámetros internos de la cuadrícula y tamaño de bloque
      const COLS = 15, ROWS = 30, BLOCK_SIZE = 30;
      const INTERNAL_WIDTH = COLS * BLOCK_SIZE;   // 450px
      const INTERNAL_HEIGHT = ROWS * BLOCK_SIZE;    // 900px
      
      // Colores para las piezas fijas (aleatorios)
      const COLOR_CYCLE = ["#a52a2a", "#808080", "#8b0000", "#b8860b", "#4b0082"];
      let board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = new Array(COLS).fill(0);
      }
      
      // Definición de tetrominoes con sus formas y colores
      const tetrominoes = [
        { shape: [[-1, 0], [0, 0], [1, 0], [2, 0]], color: "cyan" },
        { shape: [[0, 0], [1, 0], [0, 1], [1, 1]], color: "yellow" },
        { shape: [[-1, 0], [0, 0], [1, 0], [0, 1]], color: "purple" },
        { shape: [[0, 0], [1, 0], [-1, 1], [0, 1]], color: "green" },
        { shape: [[-1, 0], [0, 0], [0, 1], [1, 1]], color: "red" },
        { shape: [[-1, 0], [0, 0], [1, 0], [1, -1]], color: "orange" },
        { shape: [[-1, 0], [0, 0], [1, 0], [-1, -1]], color: "blue" }
      ];
      
      // Configuración de los canvas
      const gameCanvas = document.getElementById("gameCanvas");
      const ctx = gameCanvas.getContext("2d");
      gameCanvas.width = INTERNAL_WIDTH;
      gameCanvas.height = INTERNAL_HEIGHT;
      
      const imageCanvas = document.getElementById("imageCanvas");
      const ctxImage = imageCanvas.getContext("2d");
      imageCanvas.width = INTERNAL_WIDTH;
      imageCanvas.height = INTERNAL_HEIGHT;
      
      // Imagen de fondo, que se irá revelando
      let fondo = new Image();
      let revealedRows = 0;
      let startTime = 0;
      let dropInterval = 1000, dropCounter = 0, lastTime = 0;
      let animationFrameId;
      
      // Función para dibujar cada celda
      function drawCell(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        ctx.strokeStyle = "black";
        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      }
      
      // Dibuja el tablero completo
      function drawBoard() {
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (board[r][c] !== 0) {
              drawCell(c, r, board[r][c]);
            } else {
              ctx.fillStyle = "black";
              ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
              ctx.strokeStyle = "gray";
              ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
          }
        }
      }
      
      // Dibuja la pieza actual
      function drawPiece(piece) {
        piece.shape.forEach(offset => {
          const x = piece.x + offset[0],
                y = piece.y + offset[1];
          drawCell(x, y, piece.color);
        });
      }
      
      // Genera una nueva pieza aleatoria
      function newPiece() {
        const index = Math.floor(Math.random() * tetrominoes.length);
        const shape = tetrominoes[index].shape.map(c => [...c]);
        return {
          x: Math.floor(COLS / 2),
          y: 0,
          shape,
          color: tetrominoes[index].color,
          baseColor: tetrominoes[index].color
        };
      }
      
      // Comprueba si una pieza es válida en el tablero
      function isValid(piece, board, offsetX = 0, offsetY = 0, newShape = null) {
        const shape = newShape || piece.shape;
        for (let i = 0; i < shape.length; i++) {
          const x = piece.x + shape[i][0] + offsetX;
          const y = piece.y + shape[i][1] + offsetY;
          if (x < 0 || x >= COLS || y >= ROWS) return false;
          if (y >= 0 && board[y][x] !== 0) return false;
        }
        return true;
      }
      
      // Rota la pieza (90° en sentido horario)
      function rotate(piece) {
        const newShape = piece.shape.map(coord => [-coord[1], coord[0]]);
        if (isValid(piece, board, 0, 0, newShape))
          piece.shape = newShape;
      }
      
      // Fija la pieza en el tablero y colorea las celdas
      function fixPiece(piece, board) {
        const color = COLOR_CYCLE[Math.floor(Math.random() * COLOR_CYCLE.length)];
        piece.shape.forEach(offset => {
          const x = piece.x + offset[0],
                y = piece.y + offset[1];
          if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
            board[y][x] = color;
          }
        });
      }
      
      // Borra las líneas completas y ajusta la revelación de la imagen
      function clearLines() {
        let linesCleared = 0;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (board[r].every(cell => cell !== 0)) {
            board.splice(r, 1);
            board.unshift(new Array(COLS).fill(0));
            linesCleared++;
          }
        }
        if (linesCleared > 0) {
          revealedRows += linesCleared;
          if (revealedRows > ROWS) revealedRows = ROWS;
          dropInterval *= Math.pow(0.975, linesCleared);
          drawCompletedImage();
          if (revealedRows >= ROWS) {
            const endTime = Date.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);
            alert("¡Felicidades, has completado la imagen en " + elapsed + " segundos!");
            document.removeEventListener("keydown", keydownHandler);
            cancelAnimationFrame(animationFrameId);
          }
        }
      }
      
      // Dibuja la imagen de fondo de forma que se vea completa (modo "contain")
      function drawCompletedImage() {
        ctxImage.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
        // Calcula la escala para que la imagen se ajuste totalmente en el canvas
        const scale = Math.min(imageCanvas.width / fondo.width, imageCanvas.height / fondo.height);
        const drawWidth = fondo.width * scale;
        const drawHeight = fondo.height * scale;
        const offsetX = (imageCanvas.width - drawWidth) / 2;
        const offsetY = (imageCanvas.height - drawHeight) / 2;
        // Dibuja la imagen completa, centrada en el canvas
        ctxImage.drawImage(fondo, offsetX, offsetY, drawWidth, drawHeight);
        // Crea un recubrimiento negro en la parte superior que se retira progresivamente
        const coverHeight = drawHeight * (1 - (revealedRows / ROWS));
        if (coverHeight > 0) {
          ctxImage.fillStyle = "black";
          ctxImage.fillRect(offsetX, offsetY, drawWidth, coverHeight);
        }
      }
      
      // Mueve la pieza hacia abajo o fija la pieza si no puede bajar más
      function drop() {
        if (isValid(currentPiece, board, 0, 1))
          currentPiece.y++;
        else {
          fixPiece(currentPiece, board);
          clearLines();
          currentPiece = newPiece();
          if (!isValid(currentPiece, board)) {
            alert("Game Over");
            document.removeEventListener("keydown", keydownHandler);
            cancelAnimationFrame(animationFrameId);
          }
        }
        dropCounter = 0;
      }
      
      // Función de actualización principal
      function update(time = 0) {
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval)
          drop();
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        drawBoard();
        drawPiece(currentPiece);
        drawCompletedImage();
        document.getElementById("timer").innerText =
          "Tiempo: " + ((Date.now() - startTime) / 1000).toFixed(2) + " s";
        animationFrameId = requestAnimationFrame(update);
      }
      
      // Manejador de eventos para teclado
      function keydownHandler(e) {
        if (e.key === "ArrowLeft" && isValid(currentPiece, board, -1, 0))
          currentPiece.x--;
        else if (e.key === "ArrowRight" && isValid(currentPiece, board, 1, 0))
          currentPiece.x++;
        else if (e.key === "ArrowDown")
          drop();
        else if (e.key === "ArrowUp")
          rotate(currentPiece);
      }
      
      document.addEventListener("keydown", keydownHandler);
      let currentPiece = newPiece();
      
      // Función para actualizar el escalado de los canvas según el tamaño de la ventana
      function updateScale() {
        const scale = Math.min(window.innerWidth / INTERNAL_WIDTH, window.innerHeight / INTERNAL_HEIGHT);
        gameCanvas.style.transform = "scale(" + scale + ")";
        imageCanvas.style.transform = "scale(" + scale + ")";
      }
      
      window.addEventListener("resize", updateScale);
      updateScale();
      
      // Función para iniciar el juego
      function startGame() {
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("gameContainer").style.display = "flex";
        startTime = Date.now();
        fondo.src = "1.jpg"; // Asegúrate de que la imagen exista en la ruta correcta
        fondo.onload = () => {
          drawCompletedImage();
          update();
        };
        // Cargar y reproducir el audio
        let audio = new Audio("https://pablojose2.github.io/recursos2/duke.mp3");
        audio.loop = true;
        audio.play();
      }
      
      document.getElementById("playButton").addEventListener("click", startGame);
    </script>
  </body>
</html>

